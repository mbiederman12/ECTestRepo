{"ast":null,"code":"/* global require, exports */\n\n/* jshint strict:false, eqnull:true */\nvar request = require('request');\n\nvar errors = require('./errors');\n\nvar pkg = require('../package.json');\n\nvar _ = require('lodash');\n\nvar generateJwt = require('./generateJwt'); // functions\n\n\nvar api;\n\nvar generateHeaders = function generateHeaders(config) {\n  return {\n    'User-Agent': 'OpenTok-Node-SDK/' + pkg.version,\n    'X-OPENTOK-AUTH': generateJwt(config),\n    Accept: 'application/json'\n  };\n};\n/**\n* An object representing an OpenTok archive.\n* <p>\n* Do not call the <code>new()</code> constructor. To start recording an archive, call the\n* {@link OpenTok#startArchive OpenTok.startArchive()} method.\n*\n* @property {Number} createdAt\n*   The time at which the archive was created, in milliseconds since the UNIX epoch.\n*\n* @property {String} duration\n*   The duration of the archive, in seconds.\n*\n* @property {Boolean} hasAudio\n*   Whether the archive has an audio track (<code>true</code>) or not (<code>false</code>).\n*   You can prevent audio from being recorded by setting\n*   <code>hasAudio</code> to <code>false</code>\n*   in the <code>options</code> parameter you pass into the\n*   {@link OpenTok#startArchive OpenTok.startArchive()} method.\n*\n* @property {Boolean} hasVideo\n*   Whether the archive has an video track (<code>true</code>) or not (<code>false</code>).\n*   You can prevent video from being recorded by setting\n*   <code>hasVideo</code> to <code>false</code>\n*   in the <code>options</code> parameter you pass into the\n*   {@link OpenTok#startArchive OpenTok.startArchive()} method.\n*\n* @property {String} id\n*   The archive ID.\n*\n* @property {String} name\n*   The name of the archive. If no name was provided when the archive was created, this is set\n*   to null.\n*\n* @property {String} streamMode\n*   The stream mode for the archive. This can be set to one of the the following:\n*\n*   <ul>\n*     <li> \"auto\" &mdash; streams included in the archive are selected automatically\n*     (the default).</li>\n*\n*     <li> \"manual\" &mdash; Specify streams to be included based on calls to the\n*    {@link OpenTok#addArchiveStream OpenTok.addArchiveStream()} and\n*    {@link OpenTok#removeArchiveStream OpenTok.removeArchiveStream()} methods.</li>\n*   </ul>\n*\n* @property {String} outputMode\n*   The output mode to be generated for this archive, which can be one of the following:\n*   <ul>\n*     <li> \"composed\" -- All streams in the archive are recorded to a single (composed) file.\n*     <li> \"individual\" -- Each stream in the archive is recorded to its own individual file.\n*   </ul>\n*\n*   See the {@link OpenTok#startArchive OpenTok.startArchive()} method.\n*\n* @property {String} projectId\n*   The API key associated with the archive.\n*\n* @property {String} reason\n* For archives with the status \"stopped\" or \"failed\", this string describes the reason\n* the archive stopped (such as \"maximum duration exceeded\") or failed.\n*\n* @property {String} resolution The resolution of the archive (either \"640x480\" or \"1280x720\").\n*   This property is only set for composed archives.\n*\n* @property {String} sessionId\n*   The session ID of the OpenTok session associated with this archive.\n*\n* @property {Number} size\n*   The size of the MP4 file. For archives that have not been generated, this value is set to 0.\n*\n* @property {String} status\n*   The status of the archive, which can be one of the following:\n*   <ul>\n*     <li> \"available\" -- The archive is available for download from the OpenTok cloud.\n*     <li> \"expired\" -- The archive is no longer available for download from the OpenTok cloud.\n*     <li> \"failed\" -- The archive recording failed.\n*     <li> \"paused\" -- The archive is in progress and no clients are publishing streams to\n*        the session. When an archive is in progress and any client publishes a stream,\n*        the status is \"started\". When an archive is \"paused\", nothing is recorded. When\n*        a client starts publishing a stream, the recording starts (or resumes). If all clients\n*        disconnect from a session that is being archived, the status changes to \"paused\", and\n*        after 60 seconds the archive recording stops (and the status changes to \"stopped\").</li>\n*     <li> \"started\" -- The archive started and is in the process of being recorded.\n*     <li> \"stopped\" -- The archive stopped recording.\n*     <li> \"uploaded\" -- The archive is available for download from the the upload target\n*          Amazon S3 bucket or Windows Azure container you set up for your\n*          <a href=\"https://tokbox.com/account\">OpenTok project</a>.\n*   </ul>\n*\n* @property {String} url\n*   The download URL of the available MP4 file. This is only set for an archive with the status set\n*   to \"available\"; for other archives, (including archives with the status \"uploaded\") this\n*   property is set to null. The download URL is obfuscated, and the file is only available from\n*   the URL for 10 minutes. To generate a new URL, call the\n*   {@link OpenTok#getArchive OpenTok.getArchive()} or\n*   {@link OpenTok#listArchives OpenTok.listArchives()} method.\n*\n* @see {@link OpenTok#deleteArchive OpenTok.deleteArchive()}\n* @see {@link OpenTok#getArchive OpenTok.getArchive()}\n* @see {@link OpenTok#startArchive OpenTok.startArchive()}\n* @see {@link OpenTok#stopArchive OpenTok.stopArchive()}\n* @see {@link OpenTok#listArchives OpenTok.listArchives()}\n*\n* @class Archive\n*/\n\n\nfunction Archive(config, properties) {\n  var hasProp = {}.hasOwnProperty;\n  var id = properties.id;\n  var key;\n\n  for (key in properties) {\n    if (hasProp.call(properties, key)) {\n      this[key] = properties[key];\n    }\n  }\n  /**\n   * Stops the recording of the archive.\n   * <p>\n   * Archives automatically stop recording after 120 minutes or when all clients have disconnected\n   * from the session being archived.\n   *\n   * @param callback {Function} The function to call upon completing the operation. Two arguments\n   * are passed to the function:\n   *\n   * <ul>\n   *\n   *   <li>\n   *      <code>error</code> &mdash; An error object (if the call to the method fails).\n   *   </li>\n   *\n   *   <li>\n   *       <code>archive</code> &mdash; The Archive object.\n   *   </li>\n   *\n   * </ul>\n   *\n   * @method #stop\n   * @memberof Archive\n   */\n\n\n  this.stop = function (callback) {\n    exports.stopArchive(config, id, callback);\n  };\n  /**\n   * Deletes the OpenTok archive.\n   * <p>\n   * You can only delete an archive which has a status of \"available\" or \"uploaded\". Deleting an\n   * archive removes its record from the list of archives. For an \"available\" archive, it also\n   * removes the archive file, making it unavailable for download.\n   *\n   * @param callback {Function} The function to call upon completing the operation. On successfully\n   * deleting the archive, the function is called with no arguments passed in. On failure, an error\n   * object is passed into the function.\n   *\n   * @method #delete\n   * @memberof Archive\n   */\n\n\n  this.delete = function (callback) {\n    exports.deleteArchive(config, id, callback);\n  };\n}\n\napi = function (config, method, path, body, callback) {\n  var rurl = config.apiEndpoint + '/v2/project/' + config.apiKey + path;\n  request.defaults(_.pick(config, 'proxy', 'timeout'))({\n    url: rurl,\n    method: method,\n    headers: generateHeaders(config),\n    json: body\n  }, callback);\n};\n\nexports.listArchives = function (config, options, callback) {\n  var qs = [];\n\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  if (typeof callback !== 'function') {\n    throw new errors.ArgumentError('No callback given to listArchives');\n  }\n\n  if (options.offset) {\n    qs.push('offset=' + parseInt(options.offset, 10));\n  }\n\n  if (options.count) {\n    qs.push('count=' + parseInt(options.count, 10));\n  }\n\n  if (options.sessionId) {\n    qs.push('sessionId=' + options.sessionId);\n  }\n\n  api(config, 'GET', '/archive?' + qs.join('&'), null, function (err, response, body) {\n    if (!err && body) {\n      try {\n        body = JSON.parse(body);\n      } catch (_err) {\n        err = _err;\n      }\n    }\n\n    if (err || response.statusCode !== 200) {\n      if (response && response.statusCode === 403) {\n        callback(new errors.AuthError('Invalid API key or secret'));\n      } else {\n        callback(new errors.RequestError('Unexpected response from OpenTok: ' + JSON.stringify(body)));\n      }\n    } else {\n      callback(null, body.items.map(function (item) {\n        return new Archive(config, item);\n      }), body.count);\n    }\n  });\n};\n\nexports.startArchive = function (ot, config, sessionId, options, callback) {\n  this.ot = ot;\n\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  if (typeof callback !== 'function') {\n    throw new errors.ArgumentError('No callback given to startArchive');\n  }\n\n  if (sessionId == null || sessionId.length === 0) {\n    callback(new errors.ArgumentError('No session ID given'));\n    return;\n  }\n\n  api(config, 'POST', '/archive', {\n    sessionId: sessionId,\n    name: options.name,\n    hasAudio: options.hasAudio,\n    hasVideo: options.hasVideo,\n    outputMode: options.outputMode,\n    layout: options.layout,\n    resolution: options.resolution,\n    streamMode: options.streamMode\n  }, function startArchiveCallback(err, response, body) {\n    if (err) {\n      callback(err);\n    } else if (response.statusCode !== 200) {\n      if (response && response.statusCode === 404) {\n        callback(new errors.ArchiveError('Session not found'));\n      } else if (response && response.statusCode === 403) {\n        callback(new errors.AuthError('Invalid API key or secret'));\n      } else if (response && response.statusCode === 409) {\n        callback(new errors.ArchiveError('Recording already in progress or session not using OpenTok Media Router'));\n      } else {\n        callback(new errors.RequestError('Unexpected response from OpenTok: ' + JSON.stringify(body)));\n      }\n    } else if (body.status !== 'started') {\n      callback(new errors.RequestError('Unexpected response from OpenTok: ' + JSON.stringify(body)));\n    } else {\n      callback(null, new Archive(config, body));\n    }\n  });\n};\n\nexports.stopArchive = function (config, archiveId, callback) {\n  if (typeof callback !== 'function') {\n    throw new errors.ArgumentError('No callback given to stopArchive');\n  }\n\n  if (archiveId == null || archiveId.length === 0) {\n    callback(new errors.ArgumentError('No archive ID given'));\n    return;\n  }\n\n  api(config, 'POST', '/archive/' + encodeURIComponent(archiveId) + '/stop', {}, function stopArchiveCallback(err, response, body) {\n    if (err) {\n      callback(err);\n    } else if (response.statusCode !== 200) {\n      if (response && response.statusCode === 404) {\n        callback(new errors.ArchiveError('Archive not found'));\n      } else if (response && response.statusCode === 409) {\n        callback(new errors.ArchiveError(body.message));\n      } else if (response && response.statusCode === 403) {\n        callback(new errors.AuthError('Invalid API key or secret'));\n      } else {\n        callback(new errors.RequestError('Unexpected response from OpenTok: ' + JSON.stringify(body)));\n      }\n    } else {\n      callback(null, new Archive(config, body));\n    }\n  });\n};\n\nexports.getArchive = function (config, archiveId, callback) {\n  if (typeof callback !== 'function') {\n    throw new errors.ArgumentError('No callback given to getArchive');\n  }\n\n  if (archiveId == null || archiveId.length === 0) {\n    callback(new errors.ArgumentError('No archive ID given'));\n    return;\n  }\n\n  api(config, 'GET', '/archive/' + archiveId, null, function getArchiveCallback(err, response, body) {\n    if (!err && body) {\n      try {\n        body = JSON.parse(body);\n      } catch (_err) {\n        err = _err;\n      }\n    }\n\n    if (err || response.statusCode !== 200) {\n      if (response && response.statusCode === 404) {\n        callback(new errors.ArchiveError('Archive not found'));\n      } else if (response && response.statusCode === 403) {\n        callback(new errors.AuthError('Invalid API key or secret'));\n      } else {\n        callback(new errors.RequestError('Unexpected response from OpenTok: ' + JSON.stringify(body)));\n      }\n    } else {\n      callback(null, new Archive(config, body));\n    }\n  });\n};\n\nfunction patchArchive(config, archiveId, options, callback) {\n  if (typeof callback !== 'function') {\n    throw new errors.ArgumentError('No callback given to deleteArchive');\n  }\n\n  if (archiveId == null || archiveId.length === 0) {\n    callback(new errors.ArgumentError('No Archive ID given'));\n    return;\n  }\n\n  if (options.addStream && options.addStream.length > 0) {\n    options = {\n      hasAudio: options.hasAudio != null ? options.hasAudio : true,\n      hasVideo: options.hasVideo != null ? options.hasVideo : true,\n      addStream: options.addStream\n    };\n  } else if (options.removeStream && options.removeStream.length > 0) {\n    options = {\n      removeStream: options.removeStream\n    };\n  } else {\n    callback(new errors.ArgumentError('Need one of addStream or removeStream'));\n  }\n\n  api(config, 'PATCH', '/archive/' + encodeURIComponent(archiveId) + '/streams', options, function patchArchiveCallback(err, response, body) {\n    if (err || response.statusCode !== 204) {\n      if (response && response.statusCode === 400) {\n        callback(new errors.ArgumentError('Invalid request: ' + JSON.stringify(body)));\n      } else if (response && response.statusCode === 403) {\n        callback(new errors.AuthError('Invalid API key or secret'));\n      } else if (response && response.statusCode === 404) {\n        callback(new errors.ArchiveError('Archive or stream not found'));\n      } else if (response && response.statusCode === 405) {\n        callback(new errors.ArchiveError('Unsupported Stream Mode'));\n      } else {\n        callback(new errors.RequestError('Unexpected response from OpenTok: ' + JSON.stringify(body)));\n      }\n    } else {\n      callback(null);\n    }\n  });\n}\n\nexports.addArchiveStream = function (config, archiveId, streamId, archiveOptions, callback) {\n  if (typeof archiveOptions === 'function') {\n    callback = archiveOptions;\n    archiveOptions = {};\n  }\n\n  if (typeof callback !== 'function') {\n    throw new errors.ArgumentError('No callback given to addArchiveStream');\n  }\n\n  if (archiveId == null || archiveId.length === 0) {\n    callback(new errors.ArgumentError('No archiveId provided'));\n    return;\n  }\n\n  if (streamId == null || streamId.length === 0) {\n    callback(new errors.ArgumentError('No streamId provided'));\n    return;\n  }\n\n  archiveOptions = {\n    addStream: streamId,\n    hasAudio: archiveOptions.hasAudio != null ? archiveOptions.hasAudio : true,\n    hasVideo: archiveOptions.hasVideo != null ? archiveOptions.hasVideo : true\n  };\n  patchArchive(config, archiveId, archiveOptions, callback);\n};\n\nexports.removeArchiveStream = function (config, archiveId, streamId, callback) {\n  if (typeof callback !== 'function') {\n    throw new errors.ArgumentError('No callback given to removeArchiveStream');\n  }\n\n  if (archiveId == null || archiveId.length === 0) {\n    callback(new errors.ArgumentError('No archiveId provided'));\n    return;\n  }\n\n  if (streamId == null || streamId.length === 0) {\n    callback(new errors.ArgumentError('No streamId provided'));\n    return;\n  }\n\n  patchArchive(config, archiveId, {\n    removeStream: streamId\n  }, callback);\n};\n\nexports.deleteArchive = function (config, archiveId, callback) {\n  if (typeof callback !== 'function') {\n    throw new errors.ArgumentError('No callback given to deleteArchive');\n  }\n\n  if (archiveId == null || archiveId.length === 0) {\n    callback(new errors.ArgumentError('No archive ID given'));\n    return;\n  }\n\n  api(config, 'DELETE', '/archive/' + encodeURIComponent(archiveId), null, function deleteArchiveCallback(err, response, body) {\n    if (err || response.statusCode !== 204) {\n      if (response && response.statusCode === 404) {\n        callback(new errors.ArchiveError('Archive not found'));\n      } else if (response && response.statusCode === 403) {\n        callback(new errors.AuthError('Invalid API key or secret'));\n      } else {\n        callback(new errors.RequestError('Unexpected response from OpenTok: ' + JSON.stringify(body)));\n      }\n    } else {\n      callback(null);\n    }\n  });\n};","map":{"version":3,"names":["request","require","errors","pkg","_","generateJwt","api","generateHeaders","config","version","Accept","Archive","properties","hasProp","hasOwnProperty","id","key","call","stop","callback","exports","stopArchive","delete","deleteArchive","method","path","body","rurl","apiEndpoint","apiKey","defaults","pick","url","headers","json","listArchives","options","qs","ArgumentError","offset","push","parseInt","count","sessionId","join","err","response","JSON","parse","_err","statusCode","AuthError","RequestError","stringify","items","map","item","startArchive","ot","length","name","hasAudio","hasVideo","outputMode","layout","resolution","streamMode","startArchiveCallback","ArchiveError","status","archiveId","encodeURIComponent","stopArchiveCallback","message","getArchive","getArchiveCallback","patchArchive","addStream","removeStream","patchArchiveCallback","addArchiveStream","streamId","archiveOptions","removeArchiveStream","deleteArchiveCallback"],"sources":["/Users/megnabiederman/node_modules/opentok/lib/archiving.js"],"sourcesContent":["/* global require, exports */\n/* jshint strict:false, eqnull:true */\n\nvar request = require('request');\nvar errors = require('./errors');\nvar pkg = require('../package.json');\nvar _ = require('lodash');\nvar generateJwt = require('./generateJwt');\n\n// functions\nvar api;\n\nvar generateHeaders = function generateHeaders(config) {\n  return {\n    'User-Agent': 'OpenTok-Node-SDK/' + pkg.version,\n    'X-OPENTOK-AUTH': generateJwt(config),\n    Accept: 'application/json'\n  };\n};\n\n/**\n* An object representing an OpenTok archive.\n* <p>\n* Do not call the <code>new()</code> constructor. To start recording an archive, call the\n* {@link OpenTok#startArchive OpenTok.startArchive()} method.\n*\n* @property {Number} createdAt\n*   The time at which the archive was created, in milliseconds since the UNIX epoch.\n*\n* @property {String} duration\n*   The duration of the archive, in seconds.\n*\n* @property {Boolean} hasAudio\n*   Whether the archive has an audio track (<code>true</code>) or not (<code>false</code>).\n*   You can prevent audio from being recorded by setting\n*   <code>hasAudio</code> to <code>false</code>\n*   in the <code>options</code> parameter you pass into the\n*   {@link OpenTok#startArchive OpenTok.startArchive()} method.\n*\n* @property {Boolean} hasVideo\n*   Whether the archive has an video track (<code>true</code>) or not (<code>false</code>).\n*   You can prevent video from being recorded by setting\n*   <code>hasVideo</code> to <code>false</code>\n*   in the <code>options</code> parameter you pass into the\n*   {@link OpenTok#startArchive OpenTok.startArchive()} method.\n*\n* @property {String} id\n*   The archive ID.\n*\n* @property {String} name\n*   The name of the archive. If no name was provided when the archive was created, this is set\n*   to null.\n*\n* @property {String} streamMode\n*   The stream mode for the archive. This can be set to one of the the following:\n*\n*   <ul>\n*     <li> \"auto\" &mdash; streams included in the archive are selected automatically\n*     (the default).</li>\n*\n*     <li> \"manual\" &mdash; Specify streams to be included based on calls to the\n*    {@link OpenTok#addArchiveStream OpenTok.addArchiveStream()} and\n*    {@link OpenTok#removeArchiveStream OpenTok.removeArchiveStream()} methods.</li>\n*   </ul>\n*\n* @property {String} outputMode\n*   The output mode to be generated for this archive, which can be one of the following:\n*   <ul>\n*     <li> \"composed\" -- All streams in the archive are recorded to a single (composed) file.\n*     <li> \"individual\" -- Each stream in the archive is recorded to its own individual file.\n*   </ul>\n*\n*   See the {@link OpenTok#startArchive OpenTok.startArchive()} method.\n*\n* @property {String} projectId\n*   The API key associated with the archive.\n*\n* @property {String} reason\n* For archives with the status \"stopped\" or \"failed\", this string describes the reason\n* the archive stopped (such as \"maximum duration exceeded\") or failed.\n*\n* @property {String} resolution The resolution of the archive (either \"640x480\" or \"1280x720\").\n*   This property is only set for composed archives.\n*\n* @property {String} sessionId\n*   The session ID of the OpenTok session associated with this archive.\n*\n* @property {Number} size\n*   The size of the MP4 file. For archives that have not been generated, this value is set to 0.\n*\n* @property {String} status\n*   The status of the archive, which can be one of the following:\n*   <ul>\n*     <li> \"available\" -- The archive is available for download from the OpenTok cloud.\n*     <li> \"expired\" -- The archive is no longer available for download from the OpenTok cloud.\n*     <li> \"failed\" -- The archive recording failed.\n*     <li> \"paused\" -- The archive is in progress and no clients are publishing streams to\n*        the session. When an archive is in progress and any client publishes a stream,\n*        the status is \"started\". When an archive is \"paused\", nothing is recorded. When\n*        a client starts publishing a stream, the recording starts (or resumes). If all clients\n*        disconnect from a session that is being archived, the status changes to \"paused\", and\n*        after 60 seconds the archive recording stops (and the status changes to \"stopped\").</li>\n*     <li> \"started\" -- The archive started and is in the process of being recorded.\n*     <li> \"stopped\" -- The archive stopped recording.\n*     <li> \"uploaded\" -- The archive is available for download from the the upload target\n*          Amazon S3 bucket or Windows Azure container you set up for your\n*          <a href=\"https://tokbox.com/account\">OpenTok project</a>.\n*   </ul>\n*\n* @property {String} url\n*   The download URL of the available MP4 file. This is only set for an archive with the status set\n*   to \"available\"; for other archives, (including archives with the status \"uploaded\") this\n*   property is set to null. The download URL is obfuscated, and the file is only available from\n*   the URL for 10 minutes. To generate a new URL, call the\n*   {@link OpenTok#getArchive OpenTok.getArchive()} or\n*   {@link OpenTok#listArchives OpenTok.listArchives()} method.\n*\n* @see {@link OpenTok#deleteArchive OpenTok.deleteArchive()}\n* @see {@link OpenTok#getArchive OpenTok.getArchive()}\n* @see {@link OpenTok#startArchive OpenTok.startArchive()}\n* @see {@link OpenTok#stopArchive OpenTok.stopArchive()}\n* @see {@link OpenTok#listArchives OpenTok.listArchives()}\n*\n* @class Archive\n*/\n\nfunction Archive(config, properties) {\n  var hasProp = {}.hasOwnProperty;\n  var id = properties.id;\n  var key;\n\n  for (key in properties) {\n    if (hasProp.call(properties, key)) {\n      this[key] = properties[key];\n    }\n  }\n\n  /**\n   * Stops the recording of the archive.\n   * <p>\n   * Archives automatically stop recording after 120 minutes or when all clients have disconnected\n   * from the session being archived.\n   *\n   * @param callback {Function} The function to call upon completing the operation. Two arguments\n   * are passed to the function:\n   *\n   * <ul>\n   *\n   *   <li>\n   *      <code>error</code> &mdash; An error object (if the call to the method fails).\n   *   </li>\n   *\n   *   <li>\n   *       <code>archive</code> &mdash; The Archive object.\n   *   </li>\n   *\n   * </ul>\n   *\n   * @method #stop\n   * @memberof Archive\n   */\n  this.stop = function (callback) {\n    exports.stopArchive(config, id, callback);\n  };\n\n  /**\n   * Deletes the OpenTok archive.\n   * <p>\n   * You can only delete an archive which has a status of \"available\" or \"uploaded\". Deleting an\n   * archive removes its record from the list of archives. For an \"available\" archive, it also\n   * removes the archive file, making it unavailable for download.\n   *\n   * @param callback {Function} The function to call upon completing the operation. On successfully\n   * deleting the archive, the function is called with no arguments passed in. On failure, an error\n   * object is passed into the function.\n   *\n   * @method #delete\n   * @memberof Archive\n   */\n  this.delete = function (callback) {\n    exports.deleteArchive(config, id, callback);\n  };\n}\n\napi = function (config, method, path, body, callback) {\n  var rurl = config.apiEndpoint + '/v2/project/' + config.apiKey + path;\n  request.defaults(_.pick(config, 'proxy', 'timeout'))(\n    {\n      url: rurl,\n      method: method,\n      headers: generateHeaders(config),\n      json: body\n    },\n    callback\n  );\n};\n\nexports.listArchives = function (config, options, callback) {\n  var qs = [];\n\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  if (typeof callback !== 'function') {\n    throw new errors.ArgumentError('No callback given to listArchives');\n  }\n  if (options.offset) {\n    qs.push('offset=' + parseInt(options.offset, 10));\n  }\n  if (options.count) {\n    qs.push('count=' + parseInt(options.count, 10));\n  }\n  if (options.sessionId) {\n    qs.push('sessionId=' + options.sessionId);\n  }\n  api(\n    config,\n    'GET',\n    '/archive?' + qs.join('&'),\n    null,\n    function (err, response, body) {\n      if (!err && body) {\n        try {\n          body = JSON.parse(body);\n        }\n        catch (_err) {\n          err = _err;\n        }\n      }\n      if (err || response.statusCode !== 200) {\n        if (response && response.statusCode === 403) {\n          callback(new errors.AuthError('Invalid API key or secret'));\n        }\n        else {\n          callback(new errors.RequestError('Unexpected response from OpenTok: ' + JSON.stringify(body)));\n        }\n      }\n      else {\n        callback(\n          null,\n          body.items.map(function (item) {\n            return new Archive(config, item);\n          }),\n          body.count\n        );\n      }\n    }\n  );\n};\n\nexports.startArchive = function (ot, config, sessionId, options, callback) {\n  this.ot = ot;\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  if (typeof callback !== 'function') {\n    throw new errors.ArgumentError('No callback given to startArchive');\n  }\n  if (sessionId == null || sessionId.length === 0) {\n    callback(new errors.ArgumentError('No session ID given'));\n    return;\n  }\n  api(\n    config,\n    'POST',\n    '/archive',\n    {\n      sessionId: sessionId,\n      name: options.name,\n      hasAudio: options.hasAudio,\n      hasVideo: options.hasVideo,\n      outputMode: options.outputMode,\n      layout: options.layout,\n      resolution: options.resolution,\n      streamMode: options.streamMode\n    },\n    function startArchiveCallback(err, response, body) {\n      if (err) {\n        callback(err);\n      }\n      else if (response.statusCode !== 200) {\n        if (response && response.statusCode === 404) {\n          callback(new errors.ArchiveError('Session not found'));\n        }\n        else if (response && response.statusCode === 403) {\n          callback(new errors.AuthError('Invalid API key or secret'));\n        }\n        else if (response && response.statusCode === 409) {\n          callback(new errors.ArchiveError('Recording already in progress or session not using OpenTok Media Router'));\n        }\n        else {\n          callback(new errors.RequestError('Unexpected response from OpenTok: ' + JSON.stringify(body)));\n        }\n      }\n      else if (body.status !== 'started') {\n        callback(new errors.RequestError('Unexpected response from OpenTok: ' + JSON.stringify(body)));\n      }\n      else {\n        callback(null, new Archive(config, body));\n      }\n    }\n  );\n};\n\nexports.stopArchive = function (config, archiveId, callback) {\n  if (typeof callback !== 'function') {\n    throw new errors.ArgumentError('No callback given to stopArchive');\n  }\n  if (archiveId == null || archiveId.length === 0) {\n    callback(new errors.ArgumentError('No archive ID given'));\n    return;\n  }\n  api(\n    config,\n    'POST',\n    '/archive/' + encodeURIComponent(archiveId) + '/stop',\n    {},\n    function stopArchiveCallback(err, response, body) {\n      if (err) {\n        callback(err);\n      }\n      else if (response.statusCode !== 200) {\n        if (response && response.statusCode === 404) {\n          callback(new errors.ArchiveError('Archive not found'));\n        }\n        else if (response && response.statusCode === 409) {\n          callback(new errors.ArchiveError(body.message));\n        }\n        else if (response && response.statusCode === 403) {\n          callback(new errors.AuthError('Invalid API key or secret'));\n        }\n        else {\n          callback(new errors.RequestError('Unexpected response from OpenTok: ' + JSON.stringify(body)));\n        }\n      }\n      else {\n        callback(null, new Archive(config, body));\n      }\n    }\n  );\n};\n\nexports.getArchive = function (config, archiveId, callback) {\n  if (typeof callback !== 'function') {\n    throw new errors.ArgumentError('No callback given to getArchive');\n  }\n  if (archiveId == null || archiveId.length === 0) {\n    callback(new errors.ArgumentError('No archive ID given'));\n    return;\n  }\n  api(\n    config,\n    'GET',\n    '/archive/' + archiveId,\n    null,\n    function getArchiveCallback(err, response, body) {\n      if (!err && body) {\n        try {\n          body = JSON.parse(body);\n        }\n        catch (_err) {\n          err = _err;\n        }\n      }\n      if (err || response.statusCode !== 200) {\n        if (response && response.statusCode === 404) {\n          callback(new errors.ArchiveError('Archive not found'));\n        }\n        else if (response && response.statusCode === 403) {\n          callback(new errors.AuthError('Invalid API key or secret'));\n        }\n        else {\n          callback(new errors.RequestError('Unexpected response from OpenTok: ' + JSON.stringify(body)));\n        }\n      }\n      else {\n        callback(null, new Archive(config, body));\n      }\n    }\n  );\n};\n\nfunction patchArchive(config, archiveId, options, callback) {\n  if (typeof callback !== 'function') {\n    throw new errors.ArgumentError('No callback given to deleteArchive');\n  }\n  if (archiveId == null || archiveId.length === 0) {\n    callback(new errors.ArgumentError('No Archive ID given'));\n    return;\n  }\n\n  if (options.addStream && options.addStream.length > 0) {\n    options = {\n      hasAudio: options.hasAudio != null ? options.hasAudio : true,\n      hasVideo: options.hasVideo != null ? options.hasVideo : true,\n      addStream: options.addStream\n    };\n  }\n  else if (options.removeStream && options.removeStream.length > 0) {\n    options = {\n      removeStream: options.removeStream\n    };\n  }\n  else {\n    callback(new errors.ArgumentError('Need one of addStream or removeStream'));\n  }\n\n  api(\n    config,\n    'PATCH',\n    '/archive/' + encodeURIComponent(archiveId) + '/streams',\n    options,\n    function patchArchiveCallback(err, response, body) {\n      if (err || response.statusCode !== 204) {\n        if (response && response.statusCode === 400) {\n          callback(new errors.ArgumentError('Invalid request: ' + JSON.stringify(body)));\n        }\n        else if (response && response.statusCode === 403) {\n          callback(new errors.AuthError('Invalid API key or secret'));\n        }\n        else if (response && response.statusCode === 404) {\n          callback(new errors.ArchiveError('Archive or stream not found'));\n        }\n        else if (response && response.statusCode === 405) {\n          callback(new errors.ArchiveError('Unsupported Stream Mode'));\n        }\n        else {\n          callback(new errors.RequestError('Unexpected response from OpenTok: ' + JSON.stringify(body)));\n        }\n      }\n      else {\n        callback(null);\n      }\n    }\n  );\n}\n\nexports.addArchiveStream = function (config, archiveId, streamId, archiveOptions, callback) {\n  if (typeof archiveOptions === 'function') {\n    callback = archiveOptions;\n    archiveOptions = {};\n  }\n  if (typeof callback !== 'function') {\n    throw new errors.ArgumentError('No callback given to addArchiveStream');\n  }\n  if (archiveId == null || archiveId.length === 0) {\n    callback(new errors.ArgumentError('No archiveId provided'));\n    return;\n  }\n  if (streamId == null || streamId.length === 0) {\n    callback(new errors.ArgumentError('No streamId provided'));\n    return;\n  }\n\n  archiveOptions = {\n    addStream: streamId,\n    hasAudio: archiveOptions.hasAudio != null ? archiveOptions.hasAudio : true,\n    hasVideo: archiveOptions.hasVideo != null ? archiveOptions.hasVideo : true\n  };\n\n  patchArchive(config, archiveId, archiveOptions, callback);\n};\n\nexports.removeArchiveStream = function (config, archiveId, streamId, callback) {\n  if (typeof callback !== 'function') {\n    throw new errors.ArgumentError('No callback given to removeArchiveStream');\n  }\n  if (archiveId == null || archiveId.length === 0) {\n    callback(new errors.ArgumentError('No archiveId provided'));\n    return;\n  }\n  if (streamId == null || streamId.length === 0) {\n    callback(new errors.ArgumentError('No streamId provided'));\n    return;\n  }\n\n  patchArchive(config, archiveId, { removeStream: streamId }, callback);\n};\n\nexports.deleteArchive = function (config, archiveId, callback) {\n  if (typeof callback !== 'function') {\n    throw new errors.ArgumentError('No callback given to deleteArchive');\n  }\n  if (archiveId == null || archiveId.length === 0) {\n    callback(new errors.ArgumentError('No archive ID given'));\n    return;\n  }\n  api(\n    config,\n    'DELETE',\n    '/archive/' + encodeURIComponent(archiveId),\n    null,\n    function deleteArchiveCallback(err, response, body) {\n      if (err || response.statusCode !== 204) {\n        if (response && response.statusCode === 404) {\n          callback(new errors.ArchiveError('Archive not found'));\n        }\n        else if (response && response.statusCode === 403) {\n          callback(new errors.AuthError('Invalid API key or secret'));\n        }\n        else {\n          callback(new errors.RequestError('Unexpected response from OpenTok: ' + JSON.stringify(body)));\n        }\n      }\n      else {\n        callback(null);\n      }\n    }\n  );\n};\n"],"mappings":"AAAA;;AACA;AAEA,IAAIA,OAAO,GAAGC,OAAO,CAAC,SAAD,CAArB;;AACA,IAAIC,MAAM,GAAGD,OAAO,CAAC,UAAD,CAApB;;AACA,IAAIE,GAAG,GAAGF,OAAO,CAAC,iBAAD,CAAjB;;AACA,IAAIG,CAAC,GAAGH,OAAO,CAAC,QAAD,CAAf;;AACA,IAAII,WAAW,GAAGJ,OAAO,CAAC,eAAD,CAAzB,C,CAEA;;;AACA,IAAIK,GAAJ;;AAEA,IAAIC,eAAe,GAAG,SAASA,eAAT,CAAyBC,MAAzB,EAAiC;EACrD,OAAO;IACL,cAAc,sBAAsBL,GAAG,CAACM,OADnC;IAEL,kBAAkBJ,WAAW,CAACG,MAAD,CAFxB;IAGLE,MAAM,EAAE;EAHH,CAAP;AAKD,CAND;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASC,OAAT,CAAiBH,MAAjB,EAAyBI,UAAzB,EAAqC;EACnC,IAAIC,OAAO,GAAG,GAAGC,cAAjB;EACA,IAAIC,EAAE,GAAGH,UAAU,CAACG,EAApB;EACA,IAAIC,GAAJ;;EAEA,KAAKA,GAAL,IAAYJ,UAAZ,EAAwB;IACtB,IAAIC,OAAO,CAACI,IAAR,CAAaL,UAAb,EAAyBI,GAAzB,CAAJ,EAAmC;MACjC,KAAKA,GAA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"},"metadata":{},"sourceType":"script"}